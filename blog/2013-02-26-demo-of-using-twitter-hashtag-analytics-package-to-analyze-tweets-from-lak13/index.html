<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Demo of Using twitter-hashtag-analytics to Analyze Tweets from #LAK13 - Bodong Chen</title>
    <meta property="og:title" content="Demo of Using twitter-hashtag-analytics to Analyze Tweets from #LAK13 - Bodong Chen">
    

    
      
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/custom.css" />

  </head>

  
  <body class="blog">
    <header class="masthead">
      <h1><a href="/">Bodong Chen</a></h1>

<p class="tagline">Crisscross Landscapes</p>

      <nav class="menu">
        <input id="menu-check" type="checkbox" />
        <label id="menu-label" for="menu-check" class="unselectable">
          <span class="icon close-icon">✕</span>
          <span class="icon open-icon">☰</span>
          <span class="text">Menu</span>
        </label>
        <ul>
        
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/blog/">Blog</a></li>
        
        <li><a href="/cv/">Publications</a></li>
        
        <li><a href="/notes/">Open Scholar</a></li>
        
        <li><a href="/teaching/">Teaching</a></li>
        
        <li><a href="/cn/">博客</a></li>
        
        <li><a href="/index.xml">Subscribe</a></li>
        
        
        </ul>
      </nav>
    </header>

    <article class="main">
      <header class="title">
      
<h1>Demo of Using twitter-hashtag-analytics to Analyze Tweets from #LAK13</h1>

<h3>
  2013-02-26</h3>
<hr>


      </header>





<p>Building on <a href="https://github.com/benmarwick/AAA2011-Tweets">Ben Marwick</a>,
<a href="http://mashe.hawksey.info/2012/01/tags-r/">Martin Hawksey</a> and <a href="http://blog.ouseful.info/2012/01/21/a-quick-view-over-a-mashe-google-spreadsheet-twitter-archive-of-ukgc2012-tweets/">Tony
Hirst</a>&rsquo;s
work on analyzing tweets with R, I started an R project for tweet
analysis, namely
<a href="https://github.com/dirkchen/twitter-hashtag-analytics">twitter-hashtag-analytics</a>.
This project is hosted on Github and welcomes anyone who&rsquo;s interested to
contribute. It is my very first attempt to write a package in R, so I
admit the capabilities of it is still limited and its structure may be
not properly planned. Any advice will be highly appreciated.</p>

<p>This demo, drafted with <a href="http://yihui.name/knitr/">knitr</a>, aims to show
the functionality of
<a href="https://github.com/dirkchen/twitter-hashtag-analytics">twitter-hashtag-analytics</a>
and also available on Github. It will evlove along with this project</p>

<h2 id="data-preparation">Data Preparation</h2>

<p>Before starting to analyze tweets, we will first load a few source files
(libraries) in this project.</p>

<pre><code># check working directory
getwd()

# note that Knitr automatically sets wd to where the Rmd file is.  so if
# you wish to run code line-by-line, you should setwd mannually.
# setwd('/home/bodong/src/r/twitter-analytics/twitter-hashtag-analytics')

# load source files
source(&quot;get_tweets.R&quot;)
source(&quot;munge_tweets.R&quot;)
source(&quot;utilities.R&quot;)
</code></pre>

<p>Then we can retrieve a Twitter hashtag dataset by searching through
Twitter API. Two other methods of retriving tweets implemented in this
project so far include <strong>retriving from Google Spreadsheet archives</strong>
(see <a href="http://mashe.hawksey.info/2013/02/twitter-archive-tagsv5/">here</a>)
and <strong>reading directly from a CSV file</strong>.</p>

<pre><code># get tweets by search
# this function is defined in get_tweets.R
df &lt;- GetTweetsBySearch('#LAK13')

# save or load data (so you can reuse data rather than search all the time)
save(df, file=&quot;./data/df.Rda&quot;)
# load(&quot;./data/df.Rda&quot;)
</code></pre>

<p>This dataset contains 108 tweets posted by 52 unique Twitter users
between 2013-02-19 and 2013-02-26.</p>

<p>Because tweet information retrieved through twitteR is kind of limited
(see its <a href="http://cran.r-project.org/web/packages/twitteR/index.html">reference
manual</a>, p.
11), we need to extract user information, such as <code>reply_to_user</code> and
<code>retweet_from_user</code>, mannually from each tweet. At the same time, the
names of metadata in twitteR are quite different from those used in the
official Twitter API, the following <code>PreprocessTweets</code> function in
<code>munge_tweets.R</code> also renames some attributes of tweets. Moreover, the
<code>PreprocessTweets</code> function also trims urls in tweets and put them in a
new column named <code>links</code>.</p>

<pre><code># preprocessing
df &lt;- PreprocessTweets(df)

# structure of df
str(df)

## 'data.frame':    108 obs. of  14 variables:
##  $ text        : chr  &quot;Introducing Drake, a kind of 'make for data' from @factual:  #lak13&quot; &quot;Getting more excited about pandas as i see it used RT @cteplovs: Using the pandas data analysis toolkit ...:  #lak13&quot; &quot;Ryan Baker's talk on Educational Datamining at #lak13 was very interesting. I think the topic fits best with what I'm doing now&quot;| __truncated__ &quot;RT @sbskmi: #LearningAnalytics tutorials + practicals in #lak13 open course: Tableau, R + Evidence Hub &quot; ...
##  $ favorited   : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
##  $ replyToSN   : logi  NA NA NA NA NA NA ...
##  $ created_at  : POSIXct, format: &quot;2013-02-26 19:35:58&quot; &quot;2013-02-26 19:10:04&quot; ...
##  $ truncated   : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
##  $ replyToSID  : chr  NA NA NA NA ...
##  $ id          : chr  &quot;306487793666891776&quot; &quot;306481273315135489&quot; &quot;306479634164363264&quot; &quot;306479439598989312&quot; ...
##  $ replyToUID  : logi  NA NA NA NA NA NA ...
##  $ statusSource: chr  &quot;&amp;lt;a href=&amp;quot;http://www.tweetdeck.com&amp;quot;&amp;gt;TweetDeck&amp;lt;/a&amp;gt;&quot; &quot;&amp;lt;a href=&amp;quot;http://www.tweetdeck.com&amp;quot;&amp;gt;TweetDeck&amp;lt;/a&amp;gt;&quot; &quot;&amp;lt;a href=&amp;quot;http://www.tweetdeck.com&amp;quot;&amp;gt;TweetDeck&amp;lt;/a&amp;gt;&quot; &quot;&amp;lt;a href=&amp;quot;http://twitter.com/&amp;quot;&amp;gt;web&amp;lt;/a&amp;gt;&quot; ...
##  $ screen_name : chr  &quot;cteplovs&quot; &quot;cab938&quot; &quot;cbokhove&quot; &quot;dgasevic&quot; ...
##  $ from_user   : chr  &quot;cteplovs&quot; &quot;cab938&quot; &quot;cbokhove&quot; &quot;dgasevic&quot; ...
##  $ reply_to    : chr  NA NA NA NA ...
##  $ retweet_from: chr  NA NA NA &quot;sbskmi&quot; ...
##  $ links       : chr  &quot;http://t.co/H6kJET9w2t&quot; &quot;http://t.co/Z0MKo85qqR&quot; NA &quot;http://t.co/baQ8yNlZqV&quot; ...
</code></pre>

<h2 id="start-from-easy-stuff-count-things">Start from Easy Stuff: Count Things</h2>

<h3 id="count-tweets-retweets-by-and-replies-to-for-each-user">Count tweets, retweets (by), and replies (to) for each user</h3>

<p>Regular statuses, retweets, and replies are three main types of tweets
we analyze. The <code>GetTweetCountTable</code> function can easily count total
tweets sent by a user, times of retweeting by other users, and number of
replies a user has received.</p>

<pre><code>require(ggplot2)
require(reshape2)

# Count tables
countTweets &lt;- GetTweetCountTable(df, &quot;from_user&quot;)
countRetweets &lt;- GetTweetCountTable(df, &quot;retweet_from&quot;)
countReplies &lt;- GetTweetCountTable(df, &quot;reply_to&quot;)

# quickly check distribution of tweets per user
qplot(countTweets$count, binwidth = 1, xlab = &quot;Number of Tweets&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/counttables1.png" alt="plot of chunk
counttables" /></p>

<pre><code># combine counts into one data frame
counts &lt;- merge(countTweets, countRetweets, by = &quot;user&quot;, all.x = TRUE)
counts &lt;- merge(counts, countReplies, by = &quot;user&quot;, all.x = TRUE)
colnames(counts) &lt;- c(&quot;user&quot;, &quot;tweets&quot;, &quot;replied_to&quot;, &quot;retweeted_by&quot;)
counts[is.na(counts)] &lt;- 0

# melt data
counts.melt &lt;- melt(counts, id.vars = c(&quot;user&quot;))

# plot (Cleveland dot plot)
ggplot(counts.melt, aes(x = user, y = value, color = variable)) + geom_point() +
    coord_flip() + ggtitle(&quot;Counts of tweets, retweets, and messages&quot;) + xlab(&quot;Counts&quot;) +
    ylab(&quot;Users&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/counttables2.png" alt="plot of chunk
counttables" /></p>

<h3 id="ratio-of-retweets-to-tweets">Ratio of retweets to tweets</h3>

<p>To get a sense how received or valued one&rsquo;s tweets were within the
community, we can further count the ratio of being retweeted by other
users to sent tweets.</p>

<pre><code># create new column 'ratio'
counts$ratio &lt;- counts$retweeted_by/counts$tweets

# plot ratio for users who have at least one rt
ggplot(counts[counts$retweeted_by &gt; 0, ], aes(x = reorder(user, ratio), y = ratio)) +
    geom_point() + coord_flip() + ggtitle(&quot;Ratio of retweets to tweets&quot;) + xlab(&quot;Users&quot;) +
    ylab(&quot;Retweets/Tweets ratio&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/ratio.png" alt="plot of chunk
ratio" /></p>

<h3 id="count-urls">Count URLs</h3>

<p>URLs embedded in tweets are important because they usually link to
important resources that are of interest to this community.</p>

<pre><code># count links
countLinks &lt;- GetTweetCountTable(df, &quot;links&quot;)
names(countLinks)[1] &lt;- &quot;url&quot;

# check top links
head(countLinks[with(countLinks, order(-count)), ])

##                       url count
## 1   https://t.co/1hj1FrD8    13
## 2   https://t.co/8Di8QcKz     7
## 3   https://t.co/cg9ItFZt     6
## 4 https://t.co/EgtjcKoU6a     4
## 5 https://t.co/jscpxQpfNA     3
## 6 https://t.co/LnZsOCNFNs     2


# plot to see distribution of links
ggplot(countLinks[countLinks$count &gt; 1, ], aes(reorder(url, count), count)) +
    geom_point() + coord_flip() + xlab(&quot;URL&quot;) + ylab(&quot;Number of messages containing the URL&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/counturls.png" alt="plot of chunk
counturls" /></p>

<h2 id="social-network-analysis-sna">Social Network Analysis (SNA)</h2>

<h3 id="visualize-social-networks">Visualize social networks</h3>

<p>An archived tweet dataset contains <code>retweeting</code> and <code>replying</code> as two
main type of links among users. Some studies looks into <code>following</code>
relations, which require further queries to Twitter. So in this demo, we
focus on <code>retweeting</code> and <code>replying</code> links.</p>

<p>The <code>CreateSNADataFrame</code> function in <code>social_analysis.R</code> provides an
easy way to create a data frame containing all edges of the requested
social network. With created edges, we can easily create an SNA graph
and visualize it with packages like <code>igraph</code> and <code>sna</code>.</p>

<pre><code># load source file first
source(&quot;social_analysis.R&quot;)

# create data frame
rt.df &lt;- CreateSNADataFrame(df, from = &quot;from_user&quot;, to = &quot;retweet_from&quot;, linkNames = &quot;rt&quot;)
rp.df &lt;- CreateSNADataFrame(df, from = &quot;from_user&quot;, to = &quot;reply_to&quot;, linkNames = &quot;rp&quot;)

# begin social network analysis plotting
require(igraph)
require(sna)
require(Matrix)
require(SparseM)

# create graph data frame (igraph)
g &lt;- graph.data.frame(rt.df, directed = TRUE)

# plot with igraph (quick and dirty)
plot.igraph(g)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sna1.png" alt="plot of chunk
sna" /></p>

<pre><code># plot with sna get adjacency matrix
mat &lt;- get.adjacency(g)
# convert to csr matrix provided by SparseM ref:
# http://cos.name/cn/topic/108758
mat.csr &lt;- as.matrix.csr(mat, ncol = ncol(mat))

# plot with sna
gplot(mat.csr)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sna2.png" alt="plot of chunk
sna" /></p>

<h3 id="basic-sna-measures">Basic SNA measures</h3>

<p>We can further compute some basic SNA measures. For instance, density of
this network is 0.027, reciprocity of users in the network is 0.9488,
and degree centralization of this network is 0.2425. These measures are
calculated as below.</p>

<pre><code># density
gden(mat.csr)

## [1] 0.02703


# reciprocity
grecip(mat.csr)

##    Mut
## 0.9488


# centralization
centralization(mat.csr, sna::degree)

## [1] 0.2425
</code></pre>

<h3 id="community-detection">Community detection</h3>

<p>A regular task in SNA is to identify communities in a network. We can do
it through the <code>walktrap.community</code> function in <code>igraph</code> package.</p>

<pre><code>g.wc &lt;- walktrap.community(g, steps = 1000, modularity = TRUE)

# number of communities
length(g.wc)

## [1] 7

# sizes of communities
sizes(g.wc)

## Community sizes
##  1  2  3  4  5  6  7
##  3  5 23  2  2  2  1

# plot
plot(as.dendrogram(g.wc))
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/detectcommunity.png" alt="plot of chunk
detectcommunity" /></p>

<p>We have detected 7 communities in this network. The largest community
contains 44.231% of all users in this dataset.</p>

<h3 id="univariate-conditional-uniform-graph-tests">Univariate Conditional Uniform Graph Tests</h3>

<p>In network analysis, people do types of tests to check whether some
aspects of a network are <em>unusual</em>. We can do such tests, namely
<em>conditional uniform graph tests</em>, through the <code>cug.test</code> function in
the <code>sna</code> package. Further information about these tests can be found
<a href="http://artax.karlin.mff.cuni.cz/r-help/library/sna/html/cug.test.html">here</a>.</p>

<pre><code># density
cug.gden &lt;- cug.test(mat.csr, gden)
plot(cug.gden)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/cug1.png" alt="plot of chunk
cug" /></p>

<pre><code>range(cug.gden$rep.stat)

## [1] 0.4531 0.5405


# reciprocity
cug.recip &lt;- cug.test(mat.csr, grecip)
plot(cug.recip)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/cug2.png" alt="plot of chunk
cug" /></p>

<pre><code>range(cug.recip$rep.stat)

## [1] 0.4495 0.5633


# transistivity
cug.gtrans &lt;- cug.test(mat.csr, gtrans)
plot(cug.gtrans)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/cug3.png" alt="plot of chunk
cug" /></p>

<pre><code>range(cug.gtrans$rep.stat)

## [1] 0.4537 0.5433


# centralisation
cug.cent &lt;- cug.test(mat.csr, centralization, FUN.arg = list(FUN = degree))
plot(cug.cent)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/cug4.png" alt="plot of chunk
cug" /></p>

<pre><code>range(cug.cent$rep.stat)

## [1] 0.06156 0.22372
</code></pre>

<h2 id="semantic-analysis">Semantic Analysis</h2>

<h3 id="words">Words</h3>

<p>Firstly, make a word cloud.</p>

<pre><code># load source file first
source(&quot;semantic_analysis.R&quot;)

# construct corpus, with regular preprocessing performed
corpus &lt;- ConstructCorpus(df$text, removeTags = TRUE, removeUsers = TRUE)

# make a word cloud
MakeWordCloud(corpus)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/wordcloud.png" alt="plot of chunk
wordcloud" /></p>

<p>This task first uses <code>ConstructCorpus</code> in <code>semantic_analysis.R</code> to
create a text corpus, and then uses <code>MakeWordCloud</code> to make a word
cloud. Please note that <code>ConstructCorpus</code> provides a number of options
such as whether to remove hashtags (#tag) or users (@user) embedded in
tweets.</p>

<p>Next we are going to create a term-document matrix for some quick
similarity computation.</p>

<pre><code># create a term document matrix only keep tokens longer than three
# characters
td.mat &lt;- TermDocumentMatrix(corpus, control = list(minWordLength = 3))
# have a quick look
td.mat

## A term-document matrix (292 terms, 108 documents)
##
## Non-/sparse entries: 746/30790
## Sparsity           : 98%
## Maximal term length: 17
## Weighting          : term frequency (tf)


# frequent words
findFreqTerms(td.mat, lowfreq = 10)

##  [1] &quot;activity&quot;   &quot;analytics&quot;  &quot;analyzing&quot;  &quot;canvas&quot;     &quot;capturing&quot;
##  [6] &quot;data&quot;       &quot;discussion&quot; &quot;feedback&quot;   &quot;fritz&quot;      &quot;john&quot;
## [11] &quot;join&quot;       &quot;learning&quot;   &quot;min&quot;        &quot;network&quot;    &quot;peer&quot;
## [16] &quot;recipes&quot;    &quot;scale&quot;      &quot;tools&quot;      &quot;using&quot;


# find related words of a word
findAssocs(td.mat, &quot;learning&quot;, 0.5)

##       min analytics  feedback     fritz      peer     scale      join
##      0.74      0.72      0.66      0.66      0.66      0.66      0.62
##     using
##      0.59
</code></pre>

<p>For more advanced similarity computation among documents and terms, I am
considering adding Latent Semantic Analysis (LSA) capability into this
package in the future.</p>

<h3 id="topic-modelling-with-latent-dirichlet-allocation-lda">Topic modelling with Latent Dirichlet Allocation (LDA)</h3>

<p>With the sparse term-document matrix created above, we can use the
<code>TrainLDAModel</code> function in <code>semantic_analysis.R</code> to train a LDA model.
(Note: I don&rsquo;t understand all of steps in the code in <code>TrainLDAModel</code>
refactored from <a href="https://github.com/benmarwick/AAA2011-Tweets">Ben Marwick&rsquo;s
repo</a>. So please help to
check it if you understand LDA.) This step may take a while depending on
the size of the dataset.</p>

<pre><code># timing start
ptm &lt;- proc.time()

# generate a LDA model
lda &lt;- TrainLDAModel(td.mat)

# time used
proc.time() - ptm

##    user  system elapsed
##  143.25    0.02  143.78
</code></pre>

<p>ThiS LDA model contains 25 topics. We can check keywords in each topic,
get relevant topics of each tweet, and compute similarity scores among
tweets based on topics they are related to.</p>

<pre><code># get keywords for each topic
lda_terms &lt;- get_terms(lda, 5)
# look at the first 5 topics
lda_terms[, 1:5]

##      Topic 1       Topic 2     Topic 3     Topic 4     Topic 5
## [1,] &quot;data&quot;        &quot;example&quot;   &quot;john&quot;      &quot;data&quot;      &quot;activity&quot;
## [2,] &quot;packages&quot;    &quot;students&quot;  &quot;research&quot;  &quot;available&quot; &quot;signals&quot;
## [3,] &quot;scientist&quot;   &quot;analytics&quot; &quot;activity&quot;  &quot;example&quot;   &quot;collaborate&quot;
## [4,] &quot;talk&quot;        &quot;engange&quot;   &quot;analyzing&quot; &quot;hub&quot;       &quot;est&quot;
## [5,] &quot;educational&quot; &quot;learning&quot;  &quot;capturing&quot; &quot;maybe&quot;     &quot;hours&quot;


# gets topic numbers per document
lda_topics &lt;- get_topics(lda, 5)
# look at the first 10 documents
lda_topics[, 1:10]

##       1  2  3  4  5  6  7  8  9 10
## [1,]  4 10  1 16 16 16 13 13 13 10
## [2,] 14 13 24  1  1 23  4  4  4 19
## [3,]  1 25  2  2  2  1 14 14 14  8
## [4,]  2  1  3  3  3  2  2  2  2 18
## [5,]  3 21  4  4  4  3  3  3  3 23


# compute similarity between two documents
CosineSimilarity(lda_topics[, 1], lda_topics[, 10])

##        [,1]
## [1,] 0.7508


# computer a similarity matrix of documents
sim.mat &lt;- sapply(1:ncol(lda_topics), function(i) {
    sapply(1:ncol(lda_topics), function(j) CosineSimilarity(lda_topics[, i],
        lda_topics[, j]))
})

# find most relevant tweets for a tweet
index &lt;- 1
ids &lt;- which(sim.mat[, index] &gt; quantile(sim.mat[, index], 0.9))
sim.doc.df &lt;- data.frame(id = ids, sim = sim.mat[, index][ids])
sim.doc.df &lt;- sim.doc.df[with(sim.doc.df, order(-sim)), ]
# indices of most relevant tweets
head(sim.doc.df$id)

## [1]  1 54 59 45 61 17
</code></pre>

<h3 id="sentiment-analysis">Sentiment Analysis</h3>

<p>This project implements three methods (with one method that depends on
<em>ViralHeat</em> not working) of analyzing sentiment of tweets. Let&rsquo;s try
function <code>ScoreSentiment</code> in <code>sentiment_analysis.R</code> implemented based on
<a href="http://jeffreybreen.wordpress.com/2011/07/04/twitter-text-mining-r-slides/">this
post</a>.</p>

<pre><code># compute sentiment scores for all tweets
scores &lt;- ScoreSentiment(df$text, .progress = &quot;text&quot;)

# plot scores
ggplot(scores, aes(x = score)) + geom_histogram(binwidth = 1) + xlab(&quot;Sentiment score&quot;) +
    ylab(&quot;Frequency&quot;) + ggtitle(&quot;Sentiment Analysis of Tweets&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sentiment1.png" alt="plot of chunk
sentiment" /></p>

<pre><code>scores &lt;- scores[with(scores, order(-score)), ]
# check happy tweets
as.character(head(scores$text, 3))
# check unhappy tweets
as.character(tail(scores$text, 3))

# check sentiment scores of tweets containing certain words create subset
# based on tweets with certain words, e.g., learning
scores.sub &lt;- subset(scores, regexpr(&quot;learning&quot;, scores$text) &gt; 0)
# plot histogram for this token
ggplot(scores.sub, aes(x = score)) + geom_histogram(binwidth = 1) + xlab(&quot;Sentiment score for the token 'learning'&quot;) +
    ylab(&quot;Frequency&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sentiment2.png" alt="plot of chunk
sentiment" /></p>

<p>Sentiment analysis with the <code>sentiment</code> package.</p>

<pre><code>scores2 &lt;- ScoreSentiment2(df$text)

# plot scores. scale_x_log10 is used because the score is based on log
# likelihood
ggplot(scores2, aes(x = score)) + geom_histogram() + xlab(&quot;Sentiment score&quot;) +
    ylab(&quot;Frequency&quot;) + ggtitle(&quot;Sentiment Analysis of Tweets&quot;) + scale_x_log10()
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sentiment21.png" alt="plot of chunk
sentiment2" /></p>

<pre><code># plot emotion
qplot(scores2$emotion)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sentiment22.png" alt="plot of chunk
sentiment2" /></p>

<pre><code># plot most likely sentiment category
qplot(scores2$best_fit)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sentiment23.png" alt="plot of chunk
sentiment2" /></p>

<p>We can further check whether these two scores are correlated.</p>

<pre><code># put them into one data frame
scores3 &lt;- data.frame(score1 = scores$score, score2 = scores2$score)

# scatterplot with regression line
ggplot(scores3, aes(x = score1, y = score2)) + geom_point() + stat_smooth(method = &quot;lm&quot;) +
    xlab(&quot;Score by counting words&quot;) + ylab(&quot;Score from sentiment package&quot;)
</code></pre>

<p><img src="https://dl.dropbox.com/u/7599158/wp/figure/sentimentcompare.png" alt="plot of chunk
sentimentcompare" /></p>

<p>Finally, this project is at its early stage. If you are interested,
check out
this <a href="https://github.com/dirkchen/twitter-hashtag-analytics">twitter-hashtag-analytics</a> repo
on Github.</p>

<p><strong>Update</strong>: Since I got a lot of emails about the post, I want to point
out that I have converted most of the work here into a Shiny app, and
you can find an updated version of the code in <a href="https://github.com/dirkchen/twitterytics-shiny">this
&ldquo;twitterytics-shiny&rdquo; Github
repo</a>.</p>


  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/blog/2012-04-16-overview-of-aera2012-tweets/">&#34;Overview&#34; of #AERA2012 Tweets</a></span>
  <span class="nav-next"><a href="/blog/2013-03-11-analyze-text-similarity-in-r-latent-semantic-analysis-and-multidimentional-scaling/">Analyze Text Similarity with R: Latent Semantic Analysis and Multidimentional Scaling</a> &rarr;</span>
</nav>



<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//meefen.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>



<script src="//yihui.name/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>

  



<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">&copy; <a href="http://bodong.ch/">Bodong Chen</a> 2018 | <a href="https://github.com/meefen">Github</a> | <a href="https://twitter.com/bod0ng">Twitter</a></div>
  
  </footer>
  </article>
  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50108133-1', 'auto');
ga('send', 'pageview');
</script>

  </body>
</html>

